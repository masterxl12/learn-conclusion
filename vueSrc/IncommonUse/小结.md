#### 1.响应式数据的理解

​	数组和对象类型当值变化是如何劫持到?

​	==对象内部==通过`defineReactive`方法，使用`Object.defineProperty`将属性进行劫持(只会劫持已经存在的属性)，==数组==则是通过====来实现.

> 多层对象是通过递归来实现劫持，Vue3中使用proxy来实现响应式数据

​	**PS:**

​	内部依赖收集怎样做到的?

​	每个属性都拥有自己的`dep属性`，存放他所依赖的`watcher`，当属性变化后会通知自己对应的`watcher`去更新。

> 引起的性能优化问题
>
> ​	(1) 对象层级过深，性能就会差
>
> ​	(2) 不需要响应数据的内容不要放到data中
>
> ​	(3) Object.freeze() 可以冻结数据 ==冻结后的数据不能使用defineProperity 重新定义==

**快速Mock**

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <h1>响应式原理</h1>
  <div id="app"></div>

  <script>
    let state = { count: 0, a: 1 }
    let active;
    // 变成响应式数据
    function defineReactive(obj) {
      for (const key in obj) {
        // 每一个属性对应一个dep(发布者)
        let value = obj[key];  // 对象定义的值
        let dep = [];
        Object.defineProperty(obj, key, {
          get() {
            if (active) {
              dep.push(active); // 依赖收集
            }
            return value;
          },
          set(newValue) {  // 触发更新
            value = newValue;
            dep.forEach(watcher => watcher())
          }
        })
      }
    }

    defineReactive(state);

    // 定义订阅者
    const watcher = (fn) => {
      active = fn;
      fn();          // 调用函数
      active = null; // 后续不再watcher中取值 不触发更新
    }

    watcher(() => {
      app.innerHTML = state.count;
    })

    watcher(() => {
      console.log('订阅者: ', state.count);
    })
  </script>
</body>

</html>
```

#### 2. vue如何检测数组变化

数组考虑性能原因: 没有使用`defineProperty`对数组的每一项进行拦截，而是选择重写数组(push,shift,pop,unshift,reverse,splice,sort)方法<u>进行重写</u>。

**PS:**

在Vue中修改数组的索引和长度是无法监控到的。需要通过以上==七种变异方法修改数组==才会触发数组对应的`watcher`进行更新。数组中==如果是对象数据类型==也会进行递归劫持。

> 如果更改索引更新数据，可以通过`Vue.$set()`进行处理，核心内部使用的是`splice()` 方法

***快速Mock***

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <div id="app"></div>
  <script>
    let state = [1, 2, 3]; // 变成响应式的数据

    let originalArray = Array.prototype; // 数组原来的方法
    let arrayMethods = Object.create(originalArray);
    // arrayMethods.__proto__ === originalArray;

    // defineReactive 定义响应式函数
    function defineReactive(obj) {
      // 函数劫持 可以在重写方法中添加自己的功能
      arrayMethods.push = function (...args) {
        originalArray.push.apply(this, args);
        // 重写方法中添加自己的功能
        render(); // 更新视图
      }
      obj.__proto__ = arrayMethods; // JS原型链
    }

    defineReactive(state); // 使用响应函数的数组，才是响应式的数组

    function render(params) {
      app.innerHTML = state;
    }

    render();
    setTimeout(() => {
      state.push(4, 5);
    }, 1000);
  </script>
</body>

</html>
```

#### 3. 模板编译原理

编译过程：(依赖的库: `vue-template-compiler`)

模板(template) -> 树(标记) -> 生成代码 -> with + Function()

如何将template转换成render函数(这里要注意的是：开发中尽量不要使用template,因为将template转化成rendre方法需要在运行时进行编译操作会有性能损耗，同时引用带有complier包的vue体积也会变大。默认`.vue`文件中的template处理是通过`vue-loader`来进行处理的并不是通过运行时的编译。)

- 将template模板解析成`ast`语法树，- `parseHTML`
- 优化AST树，主要是标记静态节点 - markUp
- 遍历AST,重新生成代码和渲染函数 - codegen

**PS:**

模板引擎的实现原理是`new Function + with`来进行实现的。

**快速Mock**

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>03-模板编译原理</title>
</head>

<body>
  <script src="./node_modules/vue-template-compiler/browser.js"></script>

  <script>

    //  template => ast => codegen => with + function 实现生成render方法
    const { ast, render } = VueTemplateCompiler.compile(`<div>abcd</div>`);
    console.log(ast, render);

    // 模板引擎的实现原理 with + new Function
    console.log(new Function(render).toString());
    /*
    function anonymous() {
      with(this){return _c('div',[_v("abcd")])}
      }
    */
    // render 方法执行完毕后生成的是虚拟DOM
    // "with(this){return _c('div',[_v("abcd")])}"
    // 代码生成 codegen 
  </script>
</body>

</html>
```

#### 4. 生命周期钩子实现

Vue的生命周期钩子就是回调函数而已，当创建组件实例的过程中会调用对应的钩子方法。

**PS:**

内部主要是使用callHook方法来调用对应的方法。核心是一个发布订阅模式，将钩子订阅好(内部使用数组的方式存储)，在对应的阶段进行发布。

**快速Mock**



