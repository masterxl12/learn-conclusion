### 一、常用快捷键

| 快捷键                       | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| command + F                  | 当前文件查找                                                 |
| command + R                  | 当前文件替换                                                 |
| command + Z                  | 撤销                                                         |
|                              |                                                              |
| commond + D                  | 复制光标或选中所在行                                         |
| Option + ↑                   | 递进式向上代码块                                             |
| commond + E                  | 显示最近打开的文件记录                                       |
| command + O                  | 查找类文件                                                   |
| command + J                  | 插入自定义动态代码块                                         |
|                              |                                                              |
| command + U                  | 进入当前方法父类或接口方法                                   |
| command + B                  | 进入光标所在方法/变量的接口或者定义处                        |
| commond + Fn + F1            | 在光标所在错误代码处显示错误信息                             |
| commond + Fn + F3            | 选中文件/文件夹，使用助记符/取消书签                         |
| Control + Space              | 基本代码补全（可能会被输入法占用）                           |
| Command + O                  | ==全局搜索类==                                               |
| command + /                  | ==注释==                                                     |
| Option + Fn + Delete         | ==删除光标后面的单词或中文语句==                             |
| Option + Delete              | ==删除光标前面的单词或中文语句==                             |
| Shift + Enter                | ==移动当前光标到下一行==                                     |
| Option + Enter               | ==idea 根据光标显示问题，提供快速修复选择，导入类包==        |
| Control + enter              | ==代码自动生成，如对象的set/get方法，构造函数，toString等==  |
| Command + N                  | ==代码自动生成，如对象的set/get方法，构造函数，toString等==  |
| Command + D                  | ==复制当前行到下一行==                                       |
| Command + Delete             | ==删除光标所在行==                                           |
| Command + P                  | ==方法参数提示==                                             |
| Option + Shift + up          | ==移动光标所在行向上移动==                                   |
| Option + Shift + down        | ==移动光标所在行向下移动==                                   |
| commond + option + L         | ==格式化代码，可对当前文件和整个包目录使用==                 |
| command + +                  | ==展开代码==                                                 |
| command + -                  | ==折叠代码==                                                 |
| Option + 右方向键            | 光标跳转到当前单词/中文语句右侧开头位置                      |
| Control + V                  | 显示版本控制常用菜单弹出层                                   |
| Option + F1                  | 显示当前文件选择目标弹出层                                   |
| Option + F7                  | 查询所选对象/变量被引用                                      |
| Control + 左方向键           | 切换当前已打开的窗口的子视图                                 |
| Control + 右方向键           | 切换当前已打开的窗口的子视图                                 |
| Control + 前方向键           | 当前光标跳转到当前文件的前一个方法名位置                     |
| Control + 后方向键           | 当前光标跳转到当前文件后一个方法名位置                       |
| Command + 1,2,3,..,9         | 显示对应数值的选项卡，1为project                             |
| Command + F3                 | 弹出书签显示层                                               |
| Control + Option + O         | 优化导入的类，可对当前文件和整个包目录使用                   |
| Commond + Option + T         | 对选中的代码弹出环绕选项弹出层                               |
| Command + 逗号               | 打开idea系统设置                                             |
| Command + Option + Enter     | 光标所在行空出一行，光标定位到新行                           |
| Command + Option + 左方向键  | 退回到上一个操作的地方                                       |
| Command + Option + 右方向键  | 前进到上一个操作的地方                                       |
| Commond + Shift + F          | 根据输入内容查找整个项目或指定文件                           |
| Commond + Shift + R          | 根据输入内容替换对应内容，范围为整个项目或指定的目录         |
| Control + Shift + J          | 自动将下一行合并到当前行末尾                                 |
| Command + Shift + Z          | 取消撤销                                                     |
| Option + 方向键下            | 递进式取消选择代码块，可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 |
| Command + Shift + O          | 通知文件名/打开文件/目录，打开目录需要在输入的内容后面多加一个正斜杠 |
| Command + Shift + U          | 对选中的代码进行大/小写轮流转换                              |
| Command + Shift + T          | 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选则 |
| Command + Shift + C          | 复制当前文件磁盘路径到剪贴板                                 |
| Control + Shift + B          | 跳转到类型声明处                                             |
| Command + Shift + /          | 代码块注释                                                   |
| Commond + Shift + ]          | 选中从光标所在位置到它顶部中括号位置                         |
| Commond + Shift + F7         | 高亮显示所有该选中文本，按esc高亮消失                        |
| Command + Shift + F12        | 编辑器最大化                                                 |
| Command + Shift + Enter      | 自动结束代码，行末自动添加分号                               |
| Control + Shift + 1,2,3,..9  | 快速添加指定数值的书签                                       |
| Commond + Shift + 左键单击   | 把光标放在某个类变量上，按此快键键可直接定位到该类中         |
| Option + Shift + 左方向键    | 在代码文件上，光标跳转到当前单词/中文句的左侧开头位置，同事选中该单词/中文语句 |
| Option + Shift + 右方向键    | 在代码文件上，光标                                           |
| Commond + Shift + 前方向键   | 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序   |
| Commond + Shift + 后方向键   | 光标放在方法名上，将方法移动到下一个方法后面，调整方法排序   |
| Option + Shift + B           | 选则/添加task                                                |
| Option + Shift + 左键双击    | 选则被双击的单词/中文语句，按住不放，可以同时选择其他单词/中文语句 |
| Command + Shift + Option + V | 无格式粘贴                                                   |
| Command + ;                  | 打开当前项目设置                                             |

### 二、反射与注解

#### 2.1 反射

##### 2.1.1 反射机制及作用

**反射机制：将类的各个组成部分封装为其他对象，反射机制**

- ​	成员变量 —> Filed[ ]
- ​    构造方法 —> Constructor [ ]
- ​    成员方法 —> Method[ ]

![image-20200317135953410](/Users/masterxl/Library/Application Support/typora-user-images/image-20200317135953410.png)

作用：

- 可以在程序运行中，操作这些对象
- 可以解耦，提高程序的扩展性

##### 2.1.2 获取Class对象的方式

 	1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象
     - ==使用场景：多用于配置文件，将类名定义在配置文件中，读取配置文件，加载类==
 	2. 类名.Class:  通过类名的属性Class获取
     - ==使用场景：多用于参数的传递==
 	3. 对象.getClass( ): 对象实例被创建后调用  getClass( )方法在Object类中定义
     - ==使用场景：多用于对象的获取字节码的方式==

```java
package com.huayun.java_demo.reflect;

import com.huayun.java_demo.domain.Person;

public class ReflectClass {
    public static void main(String[] args) throws Exception {
        // JVM查找并加载指定的类,并返回与该类相关的Class对象三种方法
        // 1. 使用new关键字获取全限定类名
        Person p = new Person();
        Class p1 = p.getClass();
        System.out.println(p1);

        // 2. 使用"类名.class"获取全限定类名
        Class<Person> p2 = Person.class;
        System.out.println(p2);

        // 3. 使用Class.forName("全限定类名")，传入的参数就是类的全限定名
        Class p3 = Class.forName("com.huayun.java_demo.domain.Person");
        System.out.println(p3);

        System.out.println(p1 == p2);
        System.out.println(p1 == p3);
    }
}
```

[Output]

```java
class com.huayun.java_demo.domain.Person
class com.huayun.java_demo.domain.Person
class com.huayun.java_demo.domain.Person
true
true
```

【结论】同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。

##### 2.1.3 Class对象功能

获取功能

###### 2.1.3.1 获取成员变量们

| `Field[]` | `getFields()`   获取所有public修饰的成员变量               |
| --------- | ---------------------------------------------------------- |
| `Field`   | `getField(String name)` 获取指定名称的public修饰的成员变量 |
| `Field[]` | `getDeclaredFields()` 获取所有的成员变量，==不考虑修饰符== |
| `Field`   | `getDeclaredField(String name)`                            |

- Field：成员变量
  - 操作
    - 设置值
      - void set(Object obj,Object value )
    - 获取值
      - get(Object obj)
    - 忽略访问权限修饰符的安全检查
      - setAccessible(true):暴力反射

###### 2.1.3.2 获取构造方法们

| `Constructor[]` | `getConstructors()`                            |
| --------------- | ---------------------------------------------- |
| `Constructor`   | `getConstructor(类... parameterTypes)`         |
| `Constructor`   | `getDeclaredConstructor(类... parameterTypes)` |
| `Constructor[]` | `getDeclaredConstructors()`                    |

```java
package com.huayun.java_demo.reflect;

import com.huayun.java_demo.domain.Person;

import java.lang.reflect.Constructor;

public class ReflectDemo {
    public static void main(String[] args) throws Exception {

        Class<Person> personClass = Person.class;
        // 1 有参数构造
        Constructor<Person> constructor = personClass.getConstructor(String.class, int.class);

        Person p = constructor.newInstance("kobe", 40);
        System.out.println(p);

        // 2 无参数构造
        Constructor<Person> constructor1 = personClass.getConstructor();
        Person p2 = constructor1.newInstance();
        System.out.println(p2);

        // 3 无参数构造的简便写法  
        Person p3 = personClass.newInstance();
        System.out.println(p3);

        System.out.println(p2 == p3);  // false

    }
}

```

【Output】

```java
Person{name='kobe', gender='null', age=40}
Person{name='null', gender='null', age=0}
Person{name='null', gender='null', age=0}
false
```

- Constructor: 构造方法
  - 创建对象：
    - `T`  `newInstance(Object... initargs)`
    - 如果使用空参数构造方法创建对象，操作可以简化：Class对象的`newInstance()`方法

###### 2.1.3.3 获取成员方法们

| `Method []` | `getMethods()`                                         |
| ----------- | ------------------------------------------------------ |
| `Method`    | `getMethod(String name, 类... parameterTypes)`         |
| `Method []` | `getDeclaredMethods()`                                 |
| `Method`    | `getDeclaredMethod(String name, 类... parameterTypes)` |

```java
package com.huayun.java_demo.reflect;

import com.huayun.java_demo.domain.Person;

import java.lang.reflect.Method;

public class ReflectMethod {
    public static void main(String[] args) throws Exception {
        Class<Person> personClass = Person.class;

        // 无参成员方法
        Method method = personClass.getMethod("eat");
        Person person = new Person();
        method.invoke(person);
        // 有参数的成员方法调用
        Method eatMethod = personClass.getMethod("eat", String.class);
        eatMethod.invoke(person, "apple");

        // 遍历输出方法名
        for (Method methodItem : personClass.getMethods()) {
            System.out.println(methodItem);
            System.out.println(methodItem.getName());
            System.out.println("------------------");
        }
    }
}
```

[outPut]

```java
eat....
eat...apple
public static void com.huayun.java_demo.domain.Person.main(java.lang.String[])
main
------------------
public java.lang.String com.huayun.java_demo.domain.Person.toString()
toString
------------------
public java.lang.String com.huayun.java_demo.domain.Person.getName()
getName
------------------
public void com.huayun.java_demo.domain.Person.setName(java.lang.String)
setName
------------------
public void com.huayun.java_demo.domain.Person.eat(java.lang.String)
eat
------------------
public void com.huayun.java_demo.domain.Person.eat()
eat
------------------
public java.lang.String com.huayun.java_demo.domain.Person.getGender()
getGender
------------------
public int com.huayun.java_demo.domain.Person.getAge()
getAge
------------------
public void com.huayun.java_demo.domain.Person.setAge(int)
setAge
------------------
public void com.huayun.java_demo.domain.Person.setGender(java.lang.String)
setGender
------------------
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
wait
------------------
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
wait
------------------
public final void java.lang.Object.wait() throws java.lang.InterruptedException
wait
------------------
public boolean java.lang.Object.equals(java.lang.Object)
equals
------------------
public native int java.lang.Object.hashCode()
hashCode
------------------
public final native java.lang.Class java.lang.Object.getClass()
getClass
------------------
public final native void java.lang.Object.notify()
notify
------------------
public final native void java.lang.Object.notifyAll()
notifyAll
------------------
```

- Method: 方法对象
  - 执行方法
    - `Object`  `invoke(Object obj, Object... args)`
  - 获取方法名称
    - `String`  `getName()`

###### 2.1.3.4 获取类名

`String`           `getName()`

```java
Person.class.getName()
```

##### 2.1.4 使用反射的综合案例

**com.huayun.java_demo.domain.Person**

```java
package com.huayun.java_demo.domain;

public class Person {
    private String name;
    private String gender;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", gender='" + gender + '\'' +
                ", age=" + age +
                '}';
    }

    public void eat() {
        System.out.println("eat....");
    }

    public void eat(String food) {
        System.out.println("eat...." + food);
    }

    public static void main(String[] args) {
        Person p = new Person();
    }
}

```

**com.huayun.java_demo.reflect.ReflectCase**

```java
package com.huayun.java_demo.reflect;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.util.Properties;

public class ReflectCase {
    public static void main(String[] args) throws Exception {
        // 1.加载配置文件
        // 1.1 创建Properties对象
        Properties pro = new Properties();
        // 1.2 加载配置文件，转换为一个集合
        ClassLoader classLoader = ReflectCase.class.getClassLoader();
        // 1.2.1 获取class目录下的配置文件
        InputStream stream = classLoader.getResourceAsStream("pro.properties");
        // System.out.println(stream);
        pro.load(stream);
        // 2. 获取配置文件中定义的数据
        // System.out.println(pro);
        String className = pro.getProperty("className");
        String methodName = pro.getProperty("methodName");

        // 3. 加载该类进内存
        Class cls = Class.forName(className);
        // 4. 创建对象
        Object obj = cls.newInstance();
        // 5.  执行方法
        // 5.1 执行无参的方法
        Method method = cls.getMethod(methodName);
        method.invoke(obj);
        // 5.2 执行有参的方法
        Method paramMethod = cls.getMethod(methodName, String.class);
        paramMethod.invoke(obj, "apple");
    }
}
```

**/Users/masterxl/Desktop/myCode/java/javaLearn/src/main/resources/pro.properties**

```java
className=com.huayun.java_demo.domain.Person
methodName=eat
```

[outPut]

```java
eat....
eat....apple
```

#### 2.2 注解

##### 2.2.1 概念描述

- JDK1.5之后的新特性
- 用于说明程序
- 使用注解：@注解名称

##### 2.2.2 作用分类

- 编写文档：通过代码里标识的注解生成文档【生成doc文档】
- 代码分析：通过代码里标识的注解对代码进行分析【使用反射】
- 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】

##### 2.2.3 JDK中预定义的一些注解

- @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。
- @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。
- @SuppressWarnings - 指示编译器去忽略注解中声明的警告。
  - 一般传递参数：all @SuppressWarnings("all")

##### 2.2.4 自定义注解

###### 1. 格式：

```java	
public @interface 注解名称{ }
```

###### 2. 本质：

注解的本质就是一个借口，该接口默认继承Annotation接口

```java
public interface MyAnno extends java.lang.annotation.Annotation{ }
```

###### 3. 接口的抽象方法

- 要求
  - 1. 属性的返回值类型有下列取值
       1. 基本数据类型
       2. String
       3. 枚举
       4. 注解
       5. 以上类型的数组
    2. 定义了属性，在使用时需要给属性赋值
       1. 定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值
       2. 若只有一个属性需要赋值，且属性的名称是value，则value可以省略，直接定义即可
       3. 数组赋值时，值使用{ }包裹，如果数组中只有一个值，则{ } 可以省略

##### 2.2.5 元注解

- @Target - 描述注解能够作用的位置。
  - ElEmentType取值：
    - TYPE： 可以作用于类上
    - METHOD：可以作用于方法上
    - FIELD：可以作用于成员变量上
- @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。
  - Retentation(RetentationPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取
- @Documented - 标记这些注解是否包含在用户文档中。
- @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)

##### 2.2.6 在程序使用（解析）注解

作用：获取注解中定义的属性值

- 获取注解定义的位置对象
- 获取指定的注解
  - **getAnnotation(Class) === 实质就是在内存中生成一个该注解接口的子类实现对象==**

```java
            public class ProImpl implements Pro{
                 String className(){
                    return "com.huayun.anno.Demo1";
                }

                 String methodName(){
                    return "show"
                 }
    				}
```

**com.huayun.anno.Pro**

```java
package com.huayun.anno;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 描述需要执行的类名、方法名
 */
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Pro {
    String className();

    String methodName();

}

```

**com.huayun.anno.Demo1**

```java
package com.huayun.anno;

public class Demo1 {
    public void show(){
        System.out.println("demo1...show...");
    }
}

```

**com.huayun.anno.ReflectTest**

```java
package com.huayun.anno;

import java.lang.reflect.Method;

/**
 * 使用注解读取配置文件
 */

@Pro(className = "com.huayun.anno.Demo1", methodName = "show")
public class ReflectTest {
    public static void main(String[] args) throws Exception {
        /**
         * 前提：不能改变该类的任何代码，可以创建任意类的对象，可以执行任意方法
         *
         */
        // 1.  解析注解
        // 1.1 获取该类的字节码文件对象
        Class<ReflectTest> reflectTestClass = ReflectTest.class;
        // 1.2 获取上边的注解对象
        Pro an = reflectTestClass.getAnnotation(Pro.class);
            /*
            执行1.2 步骤之后相当于在内存中创建一个该注解接口的子类实现对象
            public class ProImpl implements Pro{
                 String className(){
                    return "com.huayun.anno.Demo1";
                }

                 String methodName(){
                    return "show"
                 }
    				}
     */
        // 1.3 调用注解对象中定义的抽象方法，获取返回值
        // 实质就是在内存中生成一个该注解接口的子类实现对象
        String className = an.className();
        String methodName = an.methodName();
        // System.out.println(className);
        // System.out.println(methodName);

        // 2.1 加载该类进内存

        Class cls = Class.forName(className);

        // 2.2 创建对象
        Object obj = cls.newInstance();

        // 2.3 获取方法对象
        Method method = cls.getMethod(methodName);

        // 2.4 执行方法
        method.invoke(obj);
    }
}

```

**结果**

```java
// 输出结果
com.huayun.anno.Demo1
show
demo1...show...
```

### 三、IO流 

​		数据的传输，可以看做是一种数据的流动，按照流动的方向，以==内存为基准==，分为`输入input` 和`输出output` 即流向内存是输入流，流出内存的输出流。

​		Java中I/O操作主要是指使用`java.io`包下的内容，进行输入、输出操作。**输入**也叫做**读取**数据，**输出**也叫做作**写出**数据。

------

#### 3.1 IO的分类

根据数据的流向分为：**输入流**和**输出流**。

* **输入流** ：把数据从`其他设备`上读取到`内存`中的流。 
* **输出流** ：把数据从`内存` 中写出到`其他设备`上的流。

格局数据的类型分为：**字节流**和**字符流**。

* **字节流** ：以字节为单位，读写数据的流。
* **字符流** ：以字符为单位，读写数据的流。

|            |           **输入流**            |              输出流              |
| :--------: | :-----------------------------: | :------------------------------: |
| **字节流** | 字节输入流<br />**InputStream** | 字节输出流<br />**OutputStream** |
| **字符流** |   字符输入流<br />**Reader**    |    字符输出流<br />**Writer**    |

#### 3.2 字节输出流OutputStream

​		一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。

##### 3.2.1 字节输出流【OutputStream】

`java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。

* `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  
* `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。  
* `public void write(byte[] b)`：将 b.length字节从指定的字节数组写入此输出流。  
* `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  
* `public abstract void write(int b)` ：将指定的字节输出流。

> 小贴士：
>
> close方法，当完成流的操作时，必须调用此方法，释放系统资源。

##### 3.2.2 FileOutputStream类

`OutputStream`有很多子类：

`ByteArrayOutputStream `， `FileOutputStream` ， `FilterOutputStream` ， `ObjectOutputStream` ， `OutputStream` ， `PipedOutputStream`

`java.io.FileOutputStream `==类是文件输出流，用于将数据写出到文件==。

构造方法

* `public FileOutputStream(File file)`：创建文件输出流以写入由指定的 File对象表示的文件。 
* `public FileOutputStream(String name)`： 创建文件输出流以指定的名称写入文件。  
  * 参数：写入数据的目的
    * String name：目的地是一个文件的路径
    * File file：目的地是一个文件
* 构造方法的作用
  * ==创建一个FileOutputStream对象==
  * ==会根据构造方法中传递的文件/文件路径，创建一个空的文件==
  * ==会把FileOutputStream对象指向创建好的文件==

​        当创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。

##### 3.2.3 字节输出流的使用步骤

1. 创建一个FileOutputStream对象，构造方法中传递写入数据的目的地
2. 调用FileOutputStream对象中的write，把数据写入到文件中
3. 释放资源(流的使用会占用一定的内存，使用完毕要把内存清空，提供程序的效率)

```java
package com.huayun.java_demo.io;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;

public class Demo01OutputStream {
    public static void main(String[] args) throws IOException {
        // 1. 一次写一个数据
        // * 创建一个FileOutputStream对象，构造方法中传递写入数据的目的地
        FileOutputStream fos = new FileOutputStream("a.txt");
        // * 调用FileOutputStream对象中的write，把数据写入到文件中
        fos.write(97);
        // * 释放资源(流的使用会占用一定的内存，使用完毕要把内存清空，提供程序的效率)
        fos.close();

        // 2 一次写入多个字节
        // 2.1 write(byte[] b) 传入字节数组
        FileOutputStream fos1 = new FileOutputStream(new File("fos.txt"));
        byte[] bytes = {65, 66, 67, 68, 69};
        fos1.write(bytes);
        // 2.2 wirte(byte[],off,len) 传入字节数组，并指定起始位置和长度
        byte[] bytes1 = "你好".getBytes();
        System.out.println(Arrays.toString(bytes1));
        fos1.write(bytes1, 0, bytes1.length);
        fos1.close();
    }
}
```

##### 3.2.4 数据追加续写/换行

- `public FileOutputStream(File file, boolean append)`：

   创建文件输出流以写入由指定的 File对象表示的文件。  

- `public FileOutputStream(String name, boolean append)`： 

  创建文件输出流以指定的名称写入文件。  

这两个构造方法，参数中都需要传入一个boolean类型的值，`true` ==表示追加数据==，`false` 表示==清空原有数据==。这样创建的输出流对象，就可以指定是否追加续写。

```java
    public static void fosWrite() throws IOException {
        // 追加续写，指定为true，不指定则默认会清空当前文件
        FileOutputStream stream = new FileOutputStream("b.txt", true);
        for (int i = 0; i < 10; i++) {
            byte[] bytes = "你好".getBytes();
            stream.write(bytes);
            // 写出换行
            // Windows系统，换行符号是"\r\n" 。
            // linux系统    换行符号是"/n"
            // mac系统      换行符号是"\r"
            stream.write("\r".getBytes());
        }
        stream.close();
    }
```

* 回车符`\r`和换行符`\n` ：
  * 回车符：回到一行的开头（return）。
  * 换行符：下一行（newline）。
* 系统中的换行：
  * Windows系统里，每行结尾是 `回车+换行` ，即`\r\n`；
  * Unix系统里，每行结尾只有 `换行` ，即`\n`；
  * Mac系统里，每行结尾是 `回车` ，即`\r`。从 Mac OS X开始与Linux统一。

#### 3.3 字节输入流InputStream

`java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。

- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    
- `public abstract int read()`： 从输入流读取数据的下一个字节。 
- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。

> 小贴士：
>
> close方法，当完成流的操作时，必须调用此方法，释放系统资源。

##### 3.3.0 字节转String的构造方法

| 字符串的构造方法                                             | 使用说明                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| String(byte[] bytes)                                         | 通过使用平台的默认字符集解码指定的字节数组来构造新的 `String` 。 |
| **[String](itss://E1BBDAD3-A1E8-459C-AFF5-83BC2D31BFAA/java/lang/String.html#String-byte:A-int-int-)**(byte[] bytes, int offset, int length) | 通过使用平台的默认字符集解码指定的字节子阵列来构造新的 `String` 。 |

##### 3.3.1 FileInputStream: 文件字节输入流

java.io.FileInputStream extends InputStream 

作用：==把硬盘文件中的数据，读取到内存中使用==

构造方法：

* `FileInputStream(File file)`：

   通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 ==File对象 file命名==。 

* `FileInputStream(String name)`： 

  通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的==路径名 name命名==。  

  参数：读取文件的数据源

  ​		String name：文件的路径

  ​		File file：		 文件对象

- 构造方法的作用：

	1. 会创建一个FileInputStream对象
 	2. 会把FileInputStream对象指定构造方法中要读取的文件

```java
package com.huayun.java_demo.io;

import java.io.FileInputStream;
import java.io.IOException;

public class Demo02InputStream {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream("fos.txt");
        int len;
        while ((len = fis.read()) != -1) {
            System.out.println(len);
            // System.out.println((char) len);
        }
        fis.close();
    }
}
```

##### 3.3.2 读取字节数据—读取一个

```java
int read()
从输入流读取数据的下一个字节。
```

`read`方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回`-1`，代码使用：

上面代码的输出：其中fos.txt中的内容为：`ABCDE`

[Output]:输出结果对应的是ASCII码表的数据

```java
65
66
67
68
69
```

##### 3.3.3 读取字节数据—多个字节

```java
int read(byte[] b)
从输入流读取一些字节数，并将它们存储到缓冲区 b 
  
read(byte[] b, int off, int len)
从输入流读取最多 len字节的数据到一个字节数组。
```

- 方法参数byte[ ]的作用
  - **==起到缓冲作用，存储每次读取到的多个字节==**
  - **数组的长度一般定义为1024(1kB)或者1024的整数倍**
- 方法的==返回值int==
  - **==每次读取的有效字节个数==**

<img src="/Users/masterxl/Library/Application Support/typora-user-images/image-20200329221444914.png" alt="image-20200329221444914" style="zoom: 43%;" />

```java
package com.huayun.java_demo.io;

import java.io.FileInputStream;
import java.io.IOException;

public class Demo03InputStream {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream("fos.txt");
        byte[] bytes = new byte[2];
        int len = fis.read(bytes);
        System.out.println(len);                // 2
        System.out.println(new String(bytes));  // AB

        len = fis.read(bytes);
        System.out.println(len);                // 2
        System.out.println(new String(bytes));  //CD

        len = fis.read(bytes);
        System.out.println(len);                // 1
        System.out.println(new String(bytes));  // ED

        len = fis.read(bytes);
        System.out.println(len);               // -1
        System.out.println(new String(bytes)); // ED

        fis.close();
    }
}
```

##### 3.3.4 使用循环一次读取多个字节

```java
    public static void readByte() throws IOException {
        FileInputStream fis = new FileInputStream("fos.txt");
        byte[] bytes = new byte[1024]; // 一次读取1KB
        int len = 0;  // 记录每次读取的有效字节个数
        while ((len = fis.read(bytes)) != -1) {
            System.out.println(new String(bytes, 0, len));
        }
        fis.close();
    }
```

##### 3.3.5 文件复制的案例

```java
package com.huayun.java_demo.io;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Demo04FileCopy {
    public static void main(String[] args) throws IOException {
        long begin = System.currentTimeMillis();
        FileInputStream fis = new FileInputStream("/Users/masterxl/Desktop/testfile/1.png");
        FileOutputStream fos = new FileOutputStream("/Users/masterxl/Desktop/1.png");

        byte[] bytes = new byte[1024 * 5]; // 使用数组缓冲一次读取5KB
        int len = 0; // 每次读取的有效字节个数
        while ((len = fis.read(bytes)) != -1) {
            fos.write(bytes, 0, len); // 把读取的文件写入到指定目的地文件中
        }
        fos.close(); // 先关闭写入的流，写完即一定读完，但读完不一定写完
        fis.close();
        long end = System.currentTimeMillis();
        System.out.println("共耗时: " + (end - begin) + " ms");
    }
}
```

#### 3.4 字符输入流Reader

​		当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。

------

##### 3.4.1 FileReader类

`java.io.Reader`抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。

- `public void close()` ：关闭此流并释放与此流相关联的任何系统资源。    
- `public int read()`： 从输入流读取一个字符。 
- `public int read(char[] cbuf)`： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。

`java.io.FileReader `类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。

> 小贴士：
>
> 1. 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。
>
>    idea中UTF-8
>
> 2. 字节缓冲区：一个字节数组，用来临时存储字节数据。

##### 3.4.2 FileReader构造方法

- `FileReader(File file)`： 创建一个新的 FileReader ，给定要读取的File对象。   
- `FileReader(String fileName)`： 创建一个新的 FileReader ，给定要读取的文件的名称。  

当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。

##### 3.4.3 读取字符数据

###### 3.4.3.1 一次读取一个字符

**读取字符**：

- `read`方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回`-1`，循环读取

【举例】

```java
    // 一次读取一个字符
    public static void readOne() throws Exception {
        long start = System.currentTimeMillis();
        fr = new FileReader("b.txt");
        int len = 0;
        while ((len = fr.read()) != -1) {
            System.out.println((char) len);
        }
        long end = System.currentTimeMillis();
        System.out.println((end - start) + " ms");

        fr.close();
    }
```

###### 3.4.3.2 使用字符数组读取

`read(char[] chars)`，

- 每次==读取chars的长度个字符==到数组中，
- 返回读取到的有效字符个数，
- 读取到末尾时，返回`-1` ，

代码使用演示：

```java
    // 一次读取多个字符
    public static void readMore() throws Exception {
        long start = System.currentTimeMillis();
        fr = new FileReader("b.txt");
        int len = 0;
        char[] chars = new char[1024 * 2];
        while ((len = fr.read(chars)) != -1) {
            System.out.println(new String(chars, 0, len));
        }
        long end = System.currentTimeMillis();
        System.out.println((end - start) + " ms");
        fr.close();
    }
```

#### 3.5 字符输出流Writer

`java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。

- `void write(int c)` 写入单个字符。
- `void write(char[] cbuf) `写入字符数组。 
- `abstract  void write(char[] cbuf, int off, int len) `写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 
- `void write(String str) `写入字符串。 
- `void write(String str, int off, int len)` 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
- `void flush() `刷新该流的缓冲。  
- `void close()` 关闭此流，但要先刷新它。 

##### 3.5.1 FileWriter类

`java.io.FileWriter `类是内存中写出字符到磁盘文件的类。构造时使用系统默认的字符编码和默认字节缓冲区。

###### 3.5.1.1 构造方法

- `FileWriter(File file)`： 创建一个新的 FileWriter，给定要读取的File对象。   
- `FileWriter(String fileName)`： 创建一个新的 FileWriter，给定要读取的文件的名称。  

当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。

##### 3.5.2 写出单个数据

`write(int b)` 方法，每次可以写出一个字符数据

```java
    public static void writeOne() throws Exception {
        fw = new FileWriter("a.txt");
        fw.write("c");
        fw.write(65);
        fw.close();
    }
```

##### 3.5.3 关闭(close)和刷新(flush)

​		因为内置缓冲区的原因，如果==不关闭输出流，无法写出字符到文件中==。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要`flush` 方法了。

* `flush` ：刷新缓冲区，流对象可以继续使用。
* `close `:    先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。

**==小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。==**

##### **==3.5.4 写出多个数据—写出字符数组==**

`write(char[] cbuf)` 和 `write(char[] cbuf, int off, int len)` ，每次可以写出字符数组中的数据，用法类似FileOutputStream

```java
    public static void writeMoreChars() throws Exception{
        fw = new FileWriter("a.txt");
        char[] chars = "中国你好".toCharArray();
        for (char aChar : chars) {
            System.out.println(aChar);
        }
        fw.write(chars);
        fw.write(chars,2,2);
        fw.close();
    }
```

##### **==3.5.5 写出多个数据—写出字符串==**

`write(String str)` 和 `write(String str, int off, int len)` ，每次可以写出字符串中的数据，更为方便，代码使用演示

```java
    public static void writeMoreString() throws Exception{
        fw = new FileWriter("a.txt");
        String str = "中国hello***";
        fw.write(str);
        fw.write(str,2,2);
        fw.close();
    }
```

##### **3.5.6 续写和换行**：

操作类似于FileOutputStream。

```java
    public static void writeAppend() throws Exception {
        fw = new FileWriter("a.txt", true);
        fw.write("中国,");
        fw.write("\n");
        fw.write("welcome to you!!!");
        fw.close();
    }
```

